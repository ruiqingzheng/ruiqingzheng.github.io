<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>EventLoop | 工作笔记</title>
    <meta name="description" content="Hendry的博客">
    <link rel="icon" href="/img/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.eecf6a6a.css" as="style"><link rel="preload" href="/assets/js/app.f8bee57c.js" as="script"><link rel="preload" href="/assets/js/15.baf7986f.js" as="script"><link rel="prefetch" href="/assets/js/10.837bbfd0.js"><link rel="prefetch" href="/assets/js/11.bbd08110.js"><link rel="prefetch" href="/assets/js/12.eb514b46.js"><link rel="prefetch" href="/assets/js/13.e2503408.js"><link rel="prefetch" href="/assets/js/14.d97c0ac2.js"><link rel="prefetch" href="/assets/js/16.2b12bf6f.js"><link rel="prefetch" href="/assets/js/17.f7e545ac.js"><link rel="prefetch" href="/assets/js/18.70d9230d.js"><link rel="prefetch" href="/assets/js/19.0a61e7ba.js"><link rel="prefetch" href="/assets/js/2.d139c70a.js"><link rel="prefetch" href="/assets/js/20.87141f48.js"><link rel="prefetch" href="/assets/js/21.536e6d3b.js"><link rel="prefetch" href="/assets/js/22.fa3e648a.js"><link rel="prefetch" href="/assets/js/23.f6c367b9.js"><link rel="prefetch" href="/assets/js/24.a8f770f5.js"><link rel="prefetch" href="/assets/js/25.3bb8bbfc.js"><link rel="prefetch" href="/assets/js/26.1c16cfb8.js"><link rel="prefetch" href="/assets/js/27.075df559.js"><link rel="prefetch" href="/assets/js/28.90c1e366.js"><link rel="prefetch" href="/assets/js/29.3145e78e.js"><link rel="prefetch" href="/assets/js/3.de89ea98.js"><link rel="prefetch" href="/assets/js/30.9832e5bd.js"><link rel="prefetch" href="/assets/js/31.2f9a7c5b.js"><link rel="prefetch" href="/assets/js/32.df9181b5.js"><link rel="prefetch" href="/assets/js/33.ec53f96d.js"><link rel="prefetch" href="/assets/js/34.398a7128.js"><link rel="prefetch" href="/assets/js/35.bb1c5a48.js"><link rel="prefetch" href="/assets/js/36.935a5449.js"><link rel="prefetch" href="/assets/js/37.459fef35.js"><link rel="prefetch" href="/assets/js/38.f51023c1.js"><link rel="prefetch" href="/assets/js/39.ed9f7023.js"><link rel="prefetch" href="/assets/js/4.a889cc83.js"><link rel="prefetch" href="/assets/js/40.7959ecc5.js"><link rel="prefetch" href="/assets/js/41.2f350c5b.js"><link rel="prefetch" href="/assets/js/42.3a09f5a5.js"><link rel="prefetch" href="/assets/js/43.b22e3395.js"><link rel="prefetch" href="/assets/js/44.ea91f873.js"><link rel="prefetch" href="/assets/js/45.29363c9f.js"><link rel="prefetch" href="/assets/js/46.45848afe.js"><link rel="prefetch" href="/assets/js/47.309f8db5.js"><link rel="prefetch" href="/assets/js/48.4da217ee.js"><link rel="prefetch" href="/assets/js/49.713e67fd.js"><link rel="prefetch" href="/assets/js/5.7183a5fb.js"><link rel="prefetch" href="/assets/js/50.d90574c6.js"><link rel="prefetch" href="/assets/js/51.5190cc6c.js"><link rel="prefetch" href="/assets/js/52.25c37497.js"><link rel="prefetch" href="/assets/js/53.3fea90a3.js"><link rel="prefetch" href="/assets/js/54.d23ad054.js"><link rel="prefetch" href="/assets/js/55.d8ba3a31.js"><link rel="prefetch" href="/assets/js/56.bc578093.js"><link rel="prefetch" href="/assets/js/57.cb8c611e.js"><link rel="prefetch" href="/assets/js/58.4a6efece.js"><link rel="prefetch" href="/assets/js/59.397f12f2.js"><link rel="prefetch" href="/assets/js/6.6621a9ba.js"><link rel="prefetch" href="/assets/js/60.a209bb60.js"><link rel="prefetch" href="/assets/js/61.0a1b1f3b.js"><link rel="prefetch" href="/assets/js/62.a79409e9.js"><link rel="prefetch" href="/assets/js/63.f99fda12.js"><link rel="prefetch" href="/assets/js/64.59a96a9c.js"><link rel="prefetch" href="/assets/js/65.ab4be186.js"><link rel="prefetch" href="/assets/js/66.df4455cd.js"><link rel="prefetch" href="/assets/js/7.a024304b.js"><link rel="prefetch" href="/assets/js/8.be16c405.js"><link rel="prefetch" href="/assets/js/9.37e77487.js">
    <link rel="stylesheet" href="/assets/css/0.styles.eecf6a6a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">工作笔记</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/menu.html" class="nav-link">首页</a></div><div class="nav-item"><a href="/Android/" class="nav-link">Android</a></div><div class="nav-item"><a href="/直播/" class="nav-link">直播</a></div><div class="nav-item"><a href="/前端/" class="nav-link">前端</a></div><div class="nav-item"><a href="/公众号/" class="nav-link">公众号</a></div><div class="nav-item"><a href="/项目/" class="nav-link">项目</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">高级</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>算法</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/language/chinese.html" class="nav-link">冒泡</a></li><li class="dropdown-subitem"><a href="/language/japanese.html" class="nav-link">快速</a></li></ul></li><li class="dropdown-item"><h4>设计模式</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/language/chinese.html" class="nav-link">工厂</a></li><li class="dropdown-subitem"><a href="/language/chinese.html" class="nav-link">单例</a></li></ul></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/menu.html" class="nav-link">首页</a></div><div class="nav-item"><a href="/Android/" class="nav-link">Android</a></div><div class="nav-item"><a href="/直播/" class="nav-link">直播</a></div><div class="nav-item"><a href="/前端/" class="nav-link">前端</a></div><div class="nav-item"><a href="/公众号/" class="nav-link">公众号</a></div><div class="nav-item"><a href="/项目/" class="nav-link">项目</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">高级</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>算法</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/language/chinese.html" class="nav-link">冒泡</a></li><li class="dropdown-subitem"><a href="/language/japanese.html" class="nav-link">快速</a></li></ul></li><li class="dropdown-item"><h4>设计模式</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/language/chinese.html" class="nav-link">工厂</a></li><li class="dropdown-subitem"><a href="/language/chinese.html" class="nav-link">单例</a></li></ul></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>EventLoop</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#相关概念" class="sidebar-link">相关概念</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#什么是-event-loop" class="sidebar-link">什么是 event loop</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#libuv" class="sidebar-link">libUv</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#event-loop-解析" class="sidebar-link">Event Loop 解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#阶段概览" class="sidebar-link">阶段概览</a></li></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#timers-阶段" class="sidebar-link">timers 阶段</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#pending-callbacks" class="sidebar-link">pending callbacks</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#poll-阶段" class="sidebar-link">poll 阶段</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#check-阶段" class="sidebar-link">check 阶段</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#close-callbacks-阶段" class="sidebar-link">close callbacks 阶段</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#setimmediate-和-settimeout" class="sidebar-link">setImmediate() 和 setTimeout()</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#process-nexttick" class="sidebar-link">process.nextTick</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#nexttick-使用场景-1" class="sidebar-link">nextTick 使用场景 1</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#nexttick-使用场景-2" class="sidebar-link">nextTick 使用场景 2</a></li></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#promise-回调" class="sidebar-link">Promise 回调</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#将回调排入-event-loop-中的方法" class="sidebar-link">将回调排入 Event Loop 中的方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#eventemitter-使用-nexttick-的例子" class="sidebar-link">EventEmitter 使用 nextTick 的例子</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#eventemitter-循环触发事件" class="sidebar-link">EventEmitter 循环触发事件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#再来个例题" class="sidebar-link">再来个例题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/EventLoop.html#参考资源" class="sidebar-link">参考资源</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="eventloop"><a href="#eventloop" aria-hidden="true" class="header-anchor">#</a> EventLoop</h1> <h2 id="相关概念"><a href="#相关概念" aria-hidden="true" class="header-anchor">#</a> 相关概念</h2> <ol><li><p>什么是异步</p> <p>简单来说就是执行的次序和代码的先后次序不一致,就是异步 (跳转和调用函数除外)</p> <p>比如, 运行某个耗时的操作, 定义其回调的代码写在前, 程序运行完后面的同步代码, 此时耗时操作完成返回结果, 则运行前面定义的回调</p> <p>前面定义的回调代码, 在后面的同步代码运行完毕后才被运行, 这样的编程方式就是异步</p> <p>反之, 如果代码的执行顺序和代码位置先后一致就是同步</p> <p>另外异步同时也还包括非阻塞的含义, 如果先定义的后执行, 那么就说明前面的代码没有执行完毕就去执行了后面的代码, 这正是非阻塞的含义</p> <p>所以, 异步不仅是代码执行顺序和书写顺序不一致, 而且异步同时就隐含了非阻塞</p></li> <li><p>什么是阻塞和非阻塞</p> <p>每条语句等待它执行结束返回后再去执行后面的语句就是阻塞模式</p> <p>非阻塞模式就是代码的执行不需要等待它返回结果就去继续执行后面的代码</p></li> <li><p>单线程</p> <p>指的是只有一个执行栈, 一次只能执行一个操作</p></li></ol> <p>js 语言是特点是单线程异步非阻塞</p> <h2 id="什么是-event-loop"><a href="#什么是-event-loop" aria-hidden="true" class="header-anchor">#</a> 什么是 event loop</h2> <p>Event Loop 是 js 实现多任务的机制, js 代码执行期间遇到阻塞操作则被提交给系统内核后台执行, 而后面的 js 代码继续执行,</p> <p>(如果是 node 环境, 系统底层就是 node 执行环境, 如果是 web 环境一般就是 v8 引擎)</p> <p>当阻塞操作返回结果, 系统内核将结果和回调发送到任务队列, Event Loop 会对任务队列进行检查一旦有返回结果则执行回调</p> <p>于是, 在执行耗时操作的同时, 后面的代码也得到执行, 通过 EventLoop 实现了多任务同时执行</p> <hr> <p>单线程是无法满足开发需求的, 比如 java, c++ 都有多线程的概念, 那么要同时运行多个任务还有没有其他方法?</p> <p>尽管 JavaScript 是单线程的，但 js 会把阻塞的操作提交给系统内核，来实现非阻塞 I/O 的功能。</p> <p>它把各种阻塞的操作都交给系统内核且不等待返回结果就去执行后面的代码,于是系统内核可能会接收到多个这种任务,</p> <p>而系统内核在运行这些操作的时候是多线程的, 他们可以在后台执行多个操作。</p> <p>当这些操作中的某一个完成后，内核便会通知 NodeJs，这样（这个操作）指定的回调就会添加到 poll 队列以便最终执行</p> <p>于是实现了 js 在同时执行多个任务</p> <p>这里还有一张图来展示这个过程：</p> <p><img src="https://pic4.zhimg.com/80/v2-da078fa3eadf3db4bf455904ae06f84b_hd.jpg" alt="img"></p> <p>// demo</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'defered code'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'last line'</span><span class="token punctuation">)</span>
</code></pre></div><p>流程说明</p> <p>先执行<code>打印 hi</code> ,当执行 <code>setTimeout</code> 的时候, 如果是浏览器运行环境那么则调用 <code>webApi</code> 的 <code>settimeout</code>,</p> <p>它是由 <code>v8</code> 底层引擎去执行这个 <code>timeout</code> 操作,</p> <p>而 <code>js</code> 非阻塞模式继续执行后面的代码, 打印 <code>last line</code> , 这时语句都执行完毕, 执行栈为空.</p> <p>此时, <code>event loop</code>会去检查自己的任务队列, 也就是专门用来保存系统底层返回值和回调的队列,</p> <p>当 v8 引擎运行判断 timeout 时间到达后, 将回调代码放到任务队列, <code>eventLoop</code> 检查任务队列发现 <code>timeout</code> 的回调, 于是打印'defered code'</p> <p>注意, eventLoop 是在执行栈中没有需要执行的任务后, 也就是同步代码都执行完毕, 才会去检查 event loop 任务队列</p> <p>这种 <code>settimeout 0</code>, 我们有时代码需要延迟执行的时候会用到</p> <h2 id="libuv"><a href="#libuv" aria-hidden="true" class="header-anchor">#</a> libUv</h2> <p>那么上面说的 js 把各种耗时操作都交给系统底层去处理, 然后底层又会把结果和回调及时执行, 这些最重要的就是 libUv 来实现的</p> <p>所以回调的处理流程, 就是 <a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener noreferrer">libUv<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 这个框架处理事件的流程, 也就是 Event Loop</p> <p><img src="http://docs.libuv.org/en/v1.x/_images/loop_iteration.png" alt="img"></p> <h2 id="event-loop-解析"><a href="#event-loop-解析" aria-hidden="true" class="header-anchor">#</a> Event Loop 解析</h2> <p>当 NodeJs 启动时，也就是单线程的执行栈被初始化, 每次只能执行一个同步操作,代码逐行先后次序放到执行栈中执行</p> <p><code>event loop</code> 也被初始化, 也被初始化</p> <p>在代码执行过程中遇到<code>异步 api 调用</code>, <code>timer</code>, <code>process.nextTick()</code> 的时候, 他们在执行栈中并不是马上执行完成的,</p> <p>js 会把这些操作提交给更底层的程序去处理, 当底层处理完这些非同步任务后(执行栈为空后回调才会被放到执行栈中运行),</p> <p>它的结果和后续的回调代码被按类别放到 6 个队列中</p> <p>这时就需要对 <code>eventLoop</code> 进行处理了, <code>eventLoop</code> 会分别对这 6 个队列依次进行检查,</p> <p>如果有底层提交上来的结果和回调被放到队列中, 那么就马上执行对应回调代码</p> <p>这 6 个队列, 也就是 6 个阶段, Event Loop 就是由这 6 个阶段组成</p> <p>每个阶段都有一个 FIFO（先进先出）的回调队列等待执行。</p> <p>虽然每个阶段都有其独特之处，但总体而言，当 event loop 进入到指定阶段后，</p> <p>它会执行该阶段的任何操作，并执行对应的回调直到队列中没有可执行回调或者达到回调执行上限，而后 event loop 会进入下一阶段。</p> <p>由于任何这些阶段的操作可能产生更多操作，内核也会将新的事件推入到 poll 阶段的队列中，</p> <p>所以新的 poll 事件被允许在处理 poll 事件时继续加入队，</p> <p>这也意味着长时间运行的回调可以允许 poll 阶段运行的时间比计时器的阈值要长</p> <h3 id="阶段概览"><a href="#阶段概览" aria-hidden="true" class="header-anchor">#</a> 阶段概览</h3> <ul><li><strong>timers</strong>：执行的是 setTimeout()和 setInterval()的回调</li> <li><strong>pending callbacks</strong>：有關系統錯誤等 Callbacks 將 queue 在此</li> <li><strong>idle, prepare</strong>：仅内部使用</li> <li><strong>poll</strong>：接收新的 I/O 事件，适当时 node 会阻塞在这里（==什么情况下是适当的？==）</li> <li><strong>check</strong>：setImmediate 回调在这里触发</li> <li><strong>close callbacks</strong>：比如 socket.on('close', ...)</li></ul> <p>在每次执行完 event loop 后，Node.js 都会检查是否还有需要等待的 I/O 或者定时器没有处理，如果没有那么进程退出。</p> <p>注: 这里的 Event Loop 阶段指的都是 libUv 的阶段, 还有 process.nextTick 和 promise 的回调也是需要 Event Loop 处理,</p> <p>但不属于 libUv 的某个阶段, 他们有自己的执行时机, 后面会说到</p> <p>或者说 node 的 Event Loop 是在 libUv 的 Event Loop 基础上加上了 process.nextTick 和 promise 的处理</p> <h2 id="timers-阶段"><a href="#timers-阶段" aria-hidden="true" class="header-anchor">#</a> timers 阶段</h2> <p>思考: 为什么 js 的 setTimeout 时间是不精确的?</p> <p>理解了 event loop 是怎么执行 timer 阶段的回调就知道答案了</p> <p>定时器会设置超时时间, 在到达超时时间后执行回调</p> <p>而实际情况是 , event loop 按上面的阶段次序去检查每个队列, 一开始的时候 timers 超时是没有到时间的, 于是继续检查后面的队列</p> <p>当 event loop 到达 poll 阶段，它的队列是空的的话, 它会在这里等待超时的时间,</p> <p>如果在这个等待期间, 有其他回调被推入 poll 队列 , 那么需要等待 poll 队列中的回调执行完毕, 直到 poll 队列为空，</p> <p>此时 event loop 才会去检查超时时间是否到达, 如果已经达到超时, 就跳回到 timer 阶段执行相应回调。</p> <p>所以 setTimout 实际的调用时间是 超时 + poll 阶段其他回调全执执行完毕需要的时间</p> <p>那如果设置的超时是 0 呢?</p> <p>如果是 0 那么当 js 的同步代码都执行完毕, event loop 开始处理的时候直接就会开始处理 timer 队列中的回调, 然后才会去检查 poll 阶段</p> <p>参考官方文档的例子</p> <h2 id="pending-callbacks"><a href="#pending-callbacks" aria-hidden="true" class="header-anchor">#</a> pending callbacks</h2> <p>简单来说, 就是当我们对一些系统异常设置回调, 这些回调都在这个阶段被执行, 也比较好理解, timeout 对时间准确的要求比较高,</p> <p>于是它的回调被放在首位执行 , 除 timer 外, 比较重要的回调就是系统异常了, 于是放在第二</p> <p>这个阶段用于执行一些系统操作的回调，比如 TCP 错误。</p> <p>举个例子，当一个 TCP socket 在尝试连接时接收到 ECONNREFUSED 的错误，一些*nix 系统会想要得到这些错误的报告，</p> <p>而这都会被推到 pending callbacks 中执行</p> <h2 id="poll-阶段"><a href="#poll-阶段" aria-hidden="true" class="header-anchor">#</a> poll 阶段</h2> <p>这个回调是很重要 ,poll 队列有回调则执行, 为空它就在这里等待,</p> <p>并检查 timer 和检查 setImmediate , 如果满足条件则跳转到其他队列执行,</p> <p>通常而言，随着代码的执行，event loop 最终会进入 poll 阶段并在这里等待新事件的到来</p> <p>流程:</p> <p>检查 poll 队列是否有回调, 有就依次执行, 直到队列为空或达到系统上限</p> <p>如果 poll 中没有回调, 则检查是否有 setImmediate 的回调, 有的话则跳到 check 阶段去执行 setImmediate 回调</p> <p>如果没有 setImmediate 回调, 那么继续在 poll 阶段等待回调被添加进来并执行</p> <p>并且一旦 poll 队列为空 event loop 就会检查 timer , 如果有 timer 到期, 那么马上跳转到 timer 去执行 timer 的回调</p> <ol><li>只要 poll 为空那么就检查 timer 是否到期, 到期则跳转 timer 阶段执行</li> <li>只要 poll 为空那么就检查是否存在 setImmediate 回调, 如果有则跳转到 check 阶段去执行</li> <li>如果 poll 为空, timer 和 setImmediate 回调都没有, 它会在这里一直等待回调被添加进来执行</li></ol> <h2 id="check-阶段"><a href="#check-阶段" aria-hidden="true" class="header-anchor">#</a> check 阶段</h2> <p>如果 poll 为空, 且存在 setImmediate, 那么 event loop 会跳过 poll 阶段的等待进入本阶段</p> <p>实际上 setImmediate()是一个特殊的定时器，它在事件循环的一个单独阶段运行，它使用 libuv API 来调度执行回调</p> <p>check 阶段专门用来执行 setImmediate()方法的回调，当 poll 阶段进入空闲状态，</p> <p>并且 setImmediate queue 中有 callback 时，事件循环进入这个阶段。</p> <h2 id="close-callbacks-阶段"><a href="#close-callbacks-阶段" aria-hidden="true" class="header-anchor">#</a> close callbacks 阶段</h2> <p>如果一个 socket 或者 handle 突然关闭（比如：socket.destory()），close 事件就会被提交到这个阶段。否则它将会通过 process.nextTick()触发</p> <p>关闭异步操作的回调, 在 libUv 的阶段是放最后执行, 否则数据还在传输, 如果先调用了 close 就把连接关闭了</p> <h2 id="setimmediate-和-settimeout"><a href="#setimmediate-和-settimeout" aria-hidden="true" class="header-anchor">#</a> setImmediate() 和 setTimeout()</h2> <p>当 poll 队列为空的时候会去检查 setImmediate 回调是否存在, 且检查 timer 是否到期, 因此这两种定时器运行的顺序是不一定的</p> <p>若满足条件则 event loop 跳转并执行, setImmediate 是在 check 队列被执行、setTimeout 是在 timer 队列被执行</p> <p>一般情况下, 如果在 poll 队列中同时满足 setImmediate 和 timer 条件, 那么 setImmediate 的回调会先执行</p> <p>如果是在其他阶段, 那么 setImmediate 和 timer 的回调顺序是先后不一定的</p> <h2 id="process-nexttick"><a href="#process-nexttick" aria-hidden="true" class="header-anchor">#</a> process.nextTick</h2> <p>process.nextTick 有自己的对应的队列 nextTickQueue, 它不属于 event loop 中的任何一个阶段, 但它依然是个异步 api</p> <p>这个队列中的方法不是由 event loop 来调用 , 它是由 c++中的 handler 通过映射某个操作来调用 nextTick 队列中的方法</p> <p>nextTick 队列中方法的调用时机:</p> <p>无论在 event loop 哪个阶段, 只要把当前阶段的操作完成, 就执行 nextTick</p> <p>所有以 process.nextTick() 所安排進來的 callbacks 都將在每一個 phase 結束，要轉換至下個 phase 之前，馬上被依序且同步地執行</p> <p>如果 event loop 还没有开始处理 , 存在有 nextTick, 那么则先运行 process.nextTick 后再去处理 event loop</p> <p>注意:</p> <ol><li><p>正因为 event loop 的继续执行是需要等待 nextTick 执行完毕, 而且 nextTick 并不像 poll 那样, 对回调有设置上限</p> <p>因此不要递归调用 process.nextTick() 这样会导致 event loop 无法到达 poll 阶段, 于是 event loop 也就无法继续工作了</p></li> <li><p>nextTickQueue 中的 callbacks 會在 Event Loop 每次準備作 phase transition 之前執行</p></li> <li><p>process.nextTick 的 callbacks 跑完, 接著跑 Promise 的 microtasks</p></li></ol> <h3 id="nexttick-使用场景-1"><a href="#nexttick-使用场景-1" aria-hidden="true" class="header-anchor">#</a> nextTick 使用场景 1</h3> <p>比如希望在用户其余代码(同步代码)执行后, event loop 回调执行前, 希望调用异步方法, 那么就可以使用 nextTick</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">apiCall</span><span class="token punctuation">(</span><span class="token parameter">arg<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> arg <span class="token operator">!==</span> <span class="token string">'string'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span>
      callback<span class="token punctuation">,</span>
      <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'argument should be string'</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是一段用于参数校验的代码，如果参数不正确就会把错误信息传递到回调。
我们（在这个例子）所做的是在保证了其余（同步）代码的执行完成后把错误传递给用户。通过使用 process.nextTick()我们可以确保 apiCall()的回调总是在其他（同步）代码运行完成后 event loop 开始前调用的。</p> <p>因为其他代码都已经调用完毕, event loop 还没有开始, 这时进程的执行栈是空的, 于是 process.nextTick 会在此时被立即执行</p> <p>再看一个 nextTick 可以解决的问题</p> <h3 id="nexttick-使用场景-2"><a href="#nexttick-使用场景-2" aria-hidden="true" class="header-anchor">#</a> nextTick 使用场景 2</h3> <p>这个例子中看起来 callApi 的参数是 callback 似乎是回调方法</p> <p>但实际上 callback 是个同步代码, 它的执行和 event loop (初始化)是平级的( 而不是 event loop 中的 phase ),</p> <p>于是 callback 中访问 bar , 因为代码还没有运行完毕 bar 还没有执行最后的一行赋值, 于是打印结果是前面的 bar 值</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">function</span> <span class="token function">callApi</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">callApi</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar is'</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span> <span class="token comment">// 0</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

bar <span class="token operator">=</span> <span class="token number">1</span>
</code></pre></div><p>// 使用 nextTick, 让代码在最后一行执行完毕后再去执行传递的回调</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">function</span> <span class="token function">callApi</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">callApi</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar is'</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

bar <span class="token operator">=</span> <span class="token number">1</span>
</code></pre></div><h2 id="promise-回调"><a href="#promise-回调" aria-hidden="true" class="header-anchor">#</a> Promise 回调</h2> <p>Promise 回调属于 microtask</p> <p>Node 官方文件上有提到，它說 process.nextTick 並不算 libuv 的 event loop phases 的一部分。</p> <p>Node 的 Event Loop 是對底層 libuv 的一層封装</p> <p>process.nextTick 與 Promise 的 microtask 都不是 libuv 的 event loop phases 的一部分</p> <p>所以當我們談論 Node 的 Event Loop，指的是在 Node 層級的 Event Loop 整體，而不僅是單單 libuv 的 event loop 本身。</p> <p>从 node 启动源码可以发现 nextTickQueue 中的回调都被执行完后, 下一步就是执行<code>_runMicroTasks</code> 来处理 <code>Promise</code> 的事情</p> <h2 id="将回调排入-event-loop-中的方法"><a href="#将回调排入-event-loop-中的方法" aria-hidden="true" class="header-anchor">#</a> 将回调排入 Event Loop 中的方法</h2> <p>如何將工作排入 Event Loop 其实也就是 Event Loop 执行回调的次序</p> <p>主要流程</p> <ul><li><p>timer 的回调队列:
使用了 timer 的 setTimeout(), setInterval() , callbacks 會被排進 timer phase 的 queue</p></li> <li><p>poll 回调队列:
呼叫了使用 libuv non-blocking IO 的 API, 如 sockets, filesystem 相關 API，在 node 裡即如 fs.readFile() 這種非同步的 API</p></li> <li><p>ckeck 回调队列:
使用 setImmediate(), callbacks 被排入 check phase 的 queue</p></li></ul> <p>另外还有 nextTick 和 promise</p> <ul><li><p>nextTickQueue
透過 process.nextTick(), 屬於 Node Event Loop 的一部分，但不屬於 libuv 的 phase。</p></li> <li><p>microTask
還有一個就是使用了 Promise (microtask) ,屬於 node event loop 的一部分，但不屬於 libuv 的 phase。</p></li></ul> <p>nextTick 是在跳转到下个阶段前执行, 紧接着执行 microTask, 都执行完毕才真正跳转到下个阶段</p> <p>比如代码中存在 nextTick , 也存在回调, 在一开始 eventLoop 还没有开始进入到任何阶段前, nextTick 会先执行</p> <p>如果已经有回调了, 在某个阶段中遇到 nextTick 代码, 那么则执行完当前队列后, 在跳转前执行 nextTick</p> <p><strong><em>nextTick -&gt; promise microTask -&gt; timer -&gt; pending -&gt; poll -&gt; check -&gt; close</em></strong></p> <p>pending 是系统异常的回调, 除 timer 对时间要求高以外, 首先就是系统错误的回调最紧急需要处理
close 是关闭异步操作的回调, 在 libUv 的阶段是放最后执行, 否则数据还在传输, 如果先调用了 close 就把连接关闭了</p> <h2 id="eventemitter-使用-nexttick-的例子"><a href="#eventemitter-使用-nexttick-的例子" aria-hidden="true" class="header-anchor">#</a> EventEmitter 使用 nextTick 的例子</h2> <p><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#what-is-the-event-loop" target="_blank" rel="noopener noreferrer">EventLoop 文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中的例子,</p> <p>在自定义事件类的构造函数中如果要触发事件,那么就需要用到 nextTick 或者 Promise.resolve().then</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> EventEmitter <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'events'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> util <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'util'</span><span class="token punctuation">)</span>

<span class="token comment">// 设置自定义事件类继承  MyEmitter.prototype == EventEmitter.prototype</span>
util<span class="token punctuation">.</span><span class="token function">inherits</span><span class="token punctuation">(</span>MyEmitter<span class="token punctuation">,</span> EventEmitter<span class="token punctuation">)</span>

<span class="token keyword">const</span> myEmitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 希望在构造函数中触发事件event</span>

<span class="token comment">// 定义构造函数</span>
<span class="token keyword">function</span> <span class="token function">MyEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这句代码可以省略, 它作用是扩展了构造函数的属性 , 生成的对象的构造函数中设置了父类属性super_</span>
  <span class="token function">EventEmitter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>

  <span class="token comment">// 构造函数中触发事件时, 无法调用回调方法, 因为回调设置语句还没有执行</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

myEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'an event occurred!'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>执行结果是回调方法没有执行, 因为构造函数中触发事件时, 事件的回调设置语句还没有执行</p> <p>fix 方法 1, 使用 nextTick:</p> <div class="language-js extra-class"><pre class="language-js"><code>process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>fix 方法 2, 使用 promiseObj.then :</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>简写</p> <div class="language-js extra-class"><pre class="language-js"><code>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>另外, 这里顺便可以比较下 nextTick 和 promise.then 的先后次序(按前面讲的 nextTick 先执行后才会 microTask)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> EventEmitter <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'events'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> util <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'util'</span><span class="token punctuation">)</span>

<span class="token comment">// 定义构造函数</span>
<span class="token keyword">function</span> <span class="token function">MyEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这句代码可以省略, 它作用是扩展了构造函数的属性 , 生成的对象的构造函数中设置了父类属性super_</span>
  <span class="token function">EventEmitter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>

  <span class="token comment">// 构造函数中触发事件时, 无法调用回调方法, 因为回调设置语句还没有执行</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">)</span>

  <span class="token comment">// fix方法1:</span>
  <span class="token comment">// process.nextTick(() =&gt; {</span>
  <span class="token comment">//   this.emit('event')</span>
  <span class="token comment">// })</span>

  <span class="token comment">// fix方法2:</span>
  <span class="token comment">// new Promise(resolve =&gt; {</span>
  <span class="token comment">//   return resolve()</span>
  <span class="token comment">// }).then(() =&gt; {</span>
  <span class="token comment">//   this.emit('event')</span>
  <span class="token comment">// })</span>
  <span class="token comment">// 简写</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// 测试nextTick 和 promise 的先后</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nextTick callback'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise callback'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 设置自定义事件类继承  MyEmitter.prototype == EventEmitter.prototype</span>
util<span class="token punctuation">.</span><span class="token function">inherits</span><span class="token punctuation">(</span>MyEmitter<span class="token punctuation">,</span> EventEmitter<span class="token punctuation">)</span>

<span class="token keyword">const</span> myEmitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 希望在构造函数中触发事件event</span>

myEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'an event occurred!'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">/***
 * 构造函数中如果直接触发事件 this.emit('event')
 * 执行的结果是, 事件的回调没有被调用
 * 因为当事件在构造函数中被触发emit的时候,
 * 事件的回调的注册代码还有执行, 也就是说事件触发了, 回调还没有注册
 * 我们需要修改确保回调注册的代码运行后, 才能发送事件, 于是采用process.nextTicket
 * 或者 用Promise 也就是MicroTask 都可以确保代码执行完毕后再去运行某些代码
 */</span>
</code></pre></div><p>输出是</p> <div class="language-s extra-class"><pre class="language-text"><code>      nextTick callback
      an event occurred!
      promise callback
</code></pre></div><p>当存在有 process.nextTick , Event Loop 的当前某阶段中的回调执行完毕后, 跳转到下个阶段前, 则执行 nextTick</p> <p>如果脚本运行完毕, Event Loop 还没有进入任何阶段, 依然是跳转下个阶段前先执行 nextTick</p> <p>总之, Event Loop 跳转到下个阶段前执行 nextTick</p> <p>而且是把 nextTickQueue 中的回调都执行完毕后, 再去执行微任务也就是 promise , promise 执行完毕后才会跳转到下个阶段</p> <h2 id="eventemitter-循环触发事件"><a href="#eventemitter-循环触发事件" aria-hidden="true" class="header-anchor">#</a> EventEmitter 循环触发事件</h2> <p>问题代码</p> <p>event1 回调中触发 event2, event2 中触发 event3 , event3 又触发 event1</p> <p>这些回调在 poll 阶段被执行, 执行回调过程中, poll 的回调队列中又不断加入新的回调方法,</p> <p>Event Loop 要等待 poll 队列中的回调清空后才能跳转到下个阶段 , 于是 poll 中的回调形成死循环</p> <p>最终会超出回调队列上限抛出异常退出</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> EventEmitter <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'events'</span><span class="token punctuation">)</span>

<span class="token keyword">var</span> crazy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

crazy<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'event1'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'event1 fired!'</span><span class="token punctuation">)</span>
  crazy<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event2'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

crazy<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'event2'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'event2 fired!'</span><span class="token punctuation">)</span>
  crazy<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event3'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

crazy<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'event3'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'event3 fired!'</span><span class="token punctuation">)</span>
  crazy<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event1'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

crazy<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event1'</span><span class="token punctuation">)</span>
</code></pre></div><p>解决方法</p> <p>使用 setImmediate , 在 setImmediate 中触发事件, 能让 EventLoop 跳转到 check 阶段去执行 setImmediate 回调
即使递归触发回调 , 因为 EventLoop 跳转的原因, 它不会在某个阶段阻塞, 利用了 EventLoop 的跳转它不是死循环,
而是 EventLoop 在跳转轮询方式在执行这些回调 , 无限跳转循环, 于是这段代码能一直正常执行</p> <div class="language-js extra-class"><pre class="language-js"><code>crazy<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'event1'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'event1 fired!'</span><span class="token punctuation">)</span>
  <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    crazy<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event2'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

crazy<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'event2'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'event2 fired!'</span><span class="token punctuation">)</span>
  <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    crazy<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event3'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

crazy<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'event3'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'event3 fired!'</span><span class="token punctuation">)</span>
  <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    crazy<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event1'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

crazy<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event1'</span><span class="token punctuation">)</span>
</code></pre></div><p>如果用 process.nextTick 的话 ?</p> <p>nextTick 是在跳转某个阶段前, 必须要自己 nextTickQueue 队列中的回调执行完毕才会跳转到下个 EventLoop 阶段
而回调中递归触发事件, 会导致 nextTickQueue 队列中的调用执行过程中, 还有回调一直被添加进来, 但是它又不属于 libUv 的回调队列, 没有设置上限,
于是看起来也能一直在跑, 但实际上还是在跑死循环 最终会导致机器内存用完, 或被操作系统提示错误</p> <h2 id="再来个例题"><a href="#再来个例题" aria-hidden="true" class="header-anchor">#</a> 再来个例题</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> eventEmitter <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'events'</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>

fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'./test'</span><span class="token punctuation">,</span> <span class="token string">'UTF-8'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    myEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">MyEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">MyEmitter</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> eventEmitter<span class="token punctuation">.</span>prototype
<span class="token class-name">MyEmitter</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> MyEmitter

<span class="token keyword">let</span> myEmitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

myEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'content:'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'process.nextTick boom!'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// Promise.resolve().then()</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout 0...'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout 1000'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>

<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setImmediate boom!'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise resolve'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><em>原本思路:</em></p> <pre><code>`Event Loop` 大概的次序是: `nextTick -&gt; promise -&gt; timer -&gt; poll -&gt; check -&gt;`
</code></pre> <ol><li>当脚本执行完毕, eventLoop 初始化, 进入阶段前执行 nextTick , 但这里的 nextTick 是在回调中设置的, 所以首先执行的是 promise</li> <li>event loop 开始处理, 进入 timer , 于是执行 timeout 为 0 的回调 , 1000 的 timeout 未到期, 继续进入下个阶段</li> <li>到了 poll 阶段等待回调, 读取到文件一定是小于 1 秒的, 于是读取到文件打印文件内容, 并发送事件 (此处有误, 后面有讲到)</li> <li>事件的回调依然被提交 poll 阶段, 于是执行 myEmitter.on 中的打印, 且设置了 nextTick
这时 timeout 1000 应该还没有到时间, poll 队列为空于是准备跳转, 而跳转前要执行 nextTick ,打印 nextTick</li> <li>进入下个阶段执行 setImmediate</li> <li>最后是 timeout 1000</li></ol> <p><strong><em>错误纠正</em></strong></p> <p>首先很容易犯的错误是认为 nextTick 会先打印, 但它是在回调中, 所以并不会先执行 nextTick,
另外一个容易犯的错误就是上面思路那样认为 poll 中的回调会比 check 中的回调先执行
但实际结果是 5 在 3 的前面执行,
因为读取文件没有 event loop 的速度快, poll 阶段没有发现回调, 就直接去 check 阶段执行了 setImmediate
直到下个 event loop 回合才去执行的 poll 中的读取文件回调和事件触发的回调
所以最后结果是</p> <div class="language-s extra-class"><pre class="language-text"><code>promise resolve
timeout 0...
setImmediate boom!
content: hello

process.nextTick boom!
timeout 1000

</code></pre></div><h2 id="参考资源"><a href="#参考资源" aria-hidden="true" class="header-anchor">#</a> 参考资源</h2> <p><a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener noreferrer">libuv doc<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&t=31s" target="_blank" rel="noopener noreferrer">JSConf 2014 Event Loop<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#what-is-the-event-loop" target="_blank" rel="noopener noreferrer">官方文档 The Node.js Event Loop, Timers, and process.nextTick()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://segmentfault.com/a/1190000017920493" target="_blank" rel="noopener noreferrer">Node.js Event Loop 文档翻译<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.youtube.com/watch?v=KjNbWQgdOwQ&t=3960s" target="_blank" rel="noopener noreferrer">Node.js 事件迴圈與 EventEmitter 视频<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.eebreakdown.com/2016/09/nodejs-eventemitter.html" target="_blank" rel="noopener noreferrer">Node.js 事件迴圈與 EventEmitter 文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://github.com/simenkid/talks/tree/master/20161025_event_loop" target="_blank" rel="noopener noreferrer">Node.js 事件迴圈與 EventEmitter 源码和课件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://zhuanlan.zhihu.com/p/33058983" target="_blank" rel="noopener noreferrer">详解 JavaScript 中的 Event Loop（事件循环）机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://lynnelv.github.io/js-event-loop-nodejs" target="_blank" rel="noopener noreferrer">深入理解 js 事件循环机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.f8bee57c.js" defer></script><script src="/assets/js/15.baf7986f.js" defer></script>
  </body>
</html>
