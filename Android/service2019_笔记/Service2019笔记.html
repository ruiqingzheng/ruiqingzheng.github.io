<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Android Service | 工作笔记</title>
    <meta name="description" content="Hendry的博客">
    <link rel="icon" href="/img/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.eecf6a6a.css" as="style"><link rel="preload" href="/assets/js/app.f8bee57c.js" as="script"><link rel="preload" href="/assets/js/6.6621a9ba.js" as="script"><link rel="prefetch" href="/assets/js/10.837bbfd0.js"><link rel="prefetch" href="/assets/js/11.bbd08110.js"><link rel="prefetch" href="/assets/js/12.eb514b46.js"><link rel="prefetch" href="/assets/js/13.e2503408.js"><link rel="prefetch" href="/assets/js/14.d97c0ac2.js"><link rel="prefetch" href="/assets/js/15.baf7986f.js"><link rel="prefetch" href="/assets/js/16.2b12bf6f.js"><link rel="prefetch" href="/assets/js/17.f7e545ac.js"><link rel="prefetch" href="/assets/js/18.70d9230d.js"><link rel="prefetch" href="/assets/js/19.0a61e7ba.js"><link rel="prefetch" href="/assets/js/2.d139c70a.js"><link rel="prefetch" href="/assets/js/20.87141f48.js"><link rel="prefetch" href="/assets/js/21.536e6d3b.js"><link rel="prefetch" href="/assets/js/22.fa3e648a.js"><link rel="prefetch" href="/assets/js/23.f6c367b9.js"><link rel="prefetch" href="/assets/js/24.a8f770f5.js"><link rel="prefetch" href="/assets/js/25.3bb8bbfc.js"><link rel="prefetch" href="/assets/js/26.1c16cfb8.js"><link rel="prefetch" href="/assets/js/27.075df559.js"><link rel="prefetch" href="/assets/js/28.90c1e366.js"><link rel="prefetch" href="/assets/js/29.3145e78e.js"><link rel="prefetch" href="/assets/js/3.de89ea98.js"><link rel="prefetch" href="/assets/js/30.9832e5bd.js"><link rel="prefetch" href="/assets/js/31.2f9a7c5b.js"><link rel="prefetch" href="/assets/js/32.df9181b5.js"><link rel="prefetch" href="/assets/js/33.ec53f96d.js"><link rel="prefetch" href="/assets/js/34.398a7128.js"><link rel="prefetch" href="/assets/js/35.bb1c5a48.js"><link rel="prefetch" href="/assets/js/36.935a5449.js"><link rel="prefetch" href="/assets/js/37.459fef35.js"><link rel="prefetch" href="/assets/js/38.f51023c1.js"><link rel="prefetch" href="/assets/js/39.ed9f7023.js"><link rel="prefetch" href="/assets/js/4.a889cc83.js"><link rel="prefetch" href="/assets/js/40.7959ecc5.js"><link rel="prefetch" href="/assets/js/41.2f350c5b.js"><link rel="prefetch" href="/assets/js/42.3a09f5a5.js"><link rel="prefetch" href="/assets/js/43.b22e3395.js"><link rel="prefetch" href="/assets/js/44.ea91f873.js"><link rel="prefetch" href="/assets/js/45.29363c9f.js"><link rel="prefetch" href="/assets/js/46.45848afe.js"><link rel="prefetch" href="/assets/js/47.309f8db5.js"><link rel="prefetch" href="/assets/js/48.4da217ee.js"><link rel="prefetch" href="/assets/js/49.713e67fd.js"><link rel="prefetch" href="/assets/js/5.7183a5fb.js"><link rel="prefetch" href="/assets/js/50.d90574c6.js"><link rel="prefetch" href="/assets/js/51.5190cc6c.js"><link rel="prefetch" href="/assets/js/52.25c37497.js"><link rel="prefetch" href="/assets/js/53.3fea90a3.js"><link rel="prefetch" href="/assets/js/54.d23ad054.js"><link rel="prefetch" href="/assets/js/55.d8ba3a31.js"><link rel="prefetch" href="/assets/js/56.bc578093.js"><link rel="prefetch" href="/assets/js/57.cb8c611e.js"><link rel="prefetch" href="/assets/js/58.4a6efece.js"><link rel="prefetch" href="/assets/js/59.397f12f2.js"><link rel="prefetch" href="/assets/js/60.a209bb60.js"><link rel="prefetch" href="/assets/js/61.0a1b1f3b.js"><link rel="prefetch" href="/assets/js/62.a79409e9.js"><link rel="prefetch" href="/assets/js/63.f99fda12.js"><link rel="prefetch" href="/assets/js/64.59a96a9c.js"><link rel="prefetch" href="/assets/js/65.ab4be186.js"><link rel="prefetch" href="/assets/js/66.df4455cd.js"><link rel="prefetch" href="/assets/js/7.a024304b.js"><link rel="prefetch" href="/assets/js/8.be16c405.js"><link rel="prefetch" href="/assets/js/9.37e77487.js">
    <link rel="stylesheet" href="/assets/css/0.styles.eecf6a6a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">工作笔记</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/menu.html" class="nav-link">首页</a></div><div class="nav-item"><a href="/Android/" class="nav-link router-link-active">Android</a></div><div class="nav-item"><a href="/直播/" class="nav-link">直播</a></div><div class="nav-item"><a href="/前端/" class="nav-link">前端</a></div><div class="nav-item"><a href="/公众号/" class="nav-link">公众号</a></div><div class="nav-item"><a href="/项目/" class="nav-link">项目</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">高级</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>算法</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/language/chinese.html" class="nav-link">冒泡</a></li><li class="dropdown-subitem"><a href="/language/japanese.html" class="nav-link">快速</a></li></ul></li><li class="dropdown-item"><h4>设计模式</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/language/chinese.html" class="nav-link">工厂</a></li><li class="dropdown-subitem"><a href="/language/chinese.html" class="nav-link">单例</a></li></ul></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/menu.html" class="nav-link">首页</a></div><div class="nav-item"><a href="/Android/" class="nav-link router-link-active">Android</a></div><div class="nav-item"><a href="/直播/" class="nav-link">直播</a></div><div class="nav-item"><a href="/前端/" class="nav-link">前端</a></div><div class="nav-item"><a href="/公众号/" class="nav-link">公众号</a></div><div class="nav-item"><a href="/项目/" class="nav-link">项目</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">高级</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>算法</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/language/chinese.html" class="nav-link">冒泡</a></li><li class="dropdown-subitem"><a href="/language/japanese.html" class="nav-link">快速</a></li></ul></li><li class="dropdown-item"><h4>设计模式</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/language/chinese.html" class="nav-link">工厂</a></li><li class="dropdown-subitem"><a href="/language/chinese.html" class="nav-link">单例</a></li></ul></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Android Service</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Android/service2019_%E7%AC%94%E8%AE%B0/Service2019%E7%AC%94%E8%AE%B0.html#service-需掌握的要点" class="sidebar-link">Service 需掌握的要点</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Android/service2019_%E7%AC%94%E8%AE%B0/Service2019%E7%AC%94%E8%AE%B0.html#service-的生命周期方法" class="sidebar-link">Service 的生命周期方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Android/service2019_%E7%AC%94%E8%AE%B0/Service2019%E7%AC%94%E8%AE%B0.html#startedservice" class="sidebar-link">StartedService</a></li><li class="sidebar-sub-header"><a href="/Android/service2019_%E7%AC%94%E8%AE%B0/Service2019%E7%AC%94%E8%AE%B0.html#boundservice" class="sidebar-link">BoundService</a></li></ul></li><li><a href="/Android/service2019_%E7%AC%94%E8%AE%B0/Service2019%E7%AC%94%E8%AE%B0.html#startedservice-使用场景" class="sidebar-link">StartedService 使用场景</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Android/service2019_%E7%AC%94%E8%AE%B0/Service2019%E7%AC%94%E8%AE%B0.html#onstartcommand-返回值" class="sidebar-link">onStartCommand 返回值</a></li><li class="sidebar-sub-header"><a href="/Android/service2019_%E7%AC%94%E8%AE%B0/Service2019%E7%AC%94%E8%AE%B0.html#startforeground-前台服务" class="sidebar-link">startForeground 前台服务</a></li></ul></li><li><a href="/Android/service2019_%E7%AC%94%E8%AE%B0/Service2019%E7%AC%94%E8%AE%B0.html#intentservice" class="sidebar-link">IntentService</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Android/service2019_%E7%AC%94%E8%AE%B0/Service2019%E7%AC%94%E8%AE%B0.html#binder" class="sidebar-link">Binder</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Android/service2019_%E7%AC%94%E8%AE%B0/Service2019%E7%AC%94%E8%AE%B0.html#本地服务" class="sidebar-link">本地服务</a></li></ul></li><li><a href="/Android/service2019_%E7%AC%94%E8%AE%B0/Service2019%E7%AC%94%E8%AE%B0.html#startedservice-和-boundservice-区别" class="sidebar-link">startedService 和 BoundService 区别</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="android-service"><a href="#android-service" aria-hidden="true" class="header-anchor">#</a> Android Service</h1> <p>文档, 但需要注意的是老版本的 doc 文档和新版本的 service 的文档并不是完全一样</p> <p>老版本看起来介绍更详细, 而新版本 9.0 文档 Service 章节更注重对 Service 的理解, 更注重在什么时候用哪种服务</p> <p><code>http://127.0.0.1:8080/guide/components/services.html</code></p> <p>还有一种是谷歌官方的中文版本文档, 但反而质量不高因为它都是机器翻译出来的, 不是结合上下文的文档翻译有的地方不知所云</p> <p>另外视频资料里面对 service 的介绍很多地方不如文档讲的透彻, 要么自己阅读英文原版文档并翻译中文</p> <p>要么找到别人已经翻译过的中文文档, 但翻译也有优劣, 这里有篇 9.0 以前的文档翻译的还不错</p> <p><code>https://blog.csdn.net/vanpersie_9987/article/details/51360245</code></p> <p>参考资源</p> <ol><li>mars 视频, 基础</li> <li>android 文档</li> <li>Android 高级应用开发课程（1-100） 基础篇 , 这里面的也很不错, b 站</li></ol> <h2 id="service-需掌握的要点"><a href="#service-需掌握的要点" aria-hidden="true" class="header-anchor">#</a> Service 需掌握的要点</h2> <ol><li><p>service 是什么</p> <p>在后台执行耗时操作的应用组件就是服务, 它没有用户界面. 文档有答案, 直接看文档</p></li> <li><p>service 不是什么</p> <p>文档种有答案, 不是新的进程 也不是新的线程, 它是运行在当前进程的, 一般为实现后台运行耗时操作, 在服务里会新开线程</p></li> <li><p>service 生命周期: 不同类型的服务有不同的生命周期 , 见后面笔记</p></li> <li><p>有哪两种 service</p> <ul><li><p>按启动方式来分类, StartedService 和 BoundService</p> <p><strong>StartedService</strong></p> <p>是通过 startService 来启动服务, 一旦服务启动, 就在后台运行,
即时启动它的 activiey 对象销毁了, 服务依然在运行,
并不是进程销毁了服务还在运行, 而是启动对象销毁它还在运行,
启动服务的进程如果被 kill 服务也会退出的</p> <p><strong>BoundService</strong></p> <p>是通过 bindService 来启动服务, 提供客户端服务接口
服务可以被多个调用者绑定<br>
ActivityA , ActivityB 都绑定服务, 有一个退出, 还有其他 activity 绑定于是服务不会退出, 所有绑定者都退出服务才会退出</p> <p>unBind()</p></li> <li><p>按服务性质分 localService 和 remoteService
remoteService , remote 是指不同的进程, 也是 cs 结构</p></li> <li><p>按实现方式来分 java 服务和 native 服务</p></li></ul></li> <li><p>service 和线程的使用的区别</p></li> <li><p>startedService 和 BoundService 区别</p></li> <li><p>service 会新开进程或线程吗</p></li> <li><p>binder 是什么?</p> <p>binder 原本是 linux 进程间通讯机制, android 在系统 binder 基础上封装后提供给开发者使用, 从而实现 android 下的进程间通信</p></li> <li><p>demo 音乐播放程序, 分别使用 startService 和 bindService</p></li></ol> <h2 id="service-的生命周期方法"><a href="#service-的生命周期方法" aria-hidden="true" class="header-anchor">#</a> Service 的生命周期方法</h2> <p><strong><em>不同的服务启动类型有不同的生命周期</em></strong></p> <p><code>StartedService</code> 类型, 指的是通过调用 <code>Context.startService()</code> 来启动服务</p> <p><code>BoundService</code> 类型, 指的是<code>Context.bindService()</code> 来启动服务</p> <hr> <p>onStartCommand()：</p> <p>当其他组件调用 startService()方法请求启动 Service 时，该方法被回调。一旦 Service 启动，它会在后台独立运行。当 Service 执行完以后，需调用 stopSelf() 或 stopService()方法停止 Service。（若您只希望 bind Service，则无需调用这些方法）</p> <p>onBind()：</p> <p>当其他组件调用 bindService()方法请求绑定 Service 时，该方法被回调。该方法返回一个 IBinder 接口，该接口是 Service 与绑定的组件进行交互的桥梁。若 Service 未绑定其他组件，该方法应返回 null。</p> <p>onCreate()：</p> <p>当 Service 第一次创建时，回调该方法。该方法只被回调一次，并在 onStartCommand() 或 onBind()方法被回调之前执行。若 Service 处于运行状态，该方法不会回调。</p> <p>onDestroy()：</p> <p>当 Service 被销毁时回调，在该方法中应清除一些占用的资源，如停止线程、接触绑定注册的监听器或 broadcast receiver 等。该方法是 Service 中的最后一个回调。</p> <h3 id="startedservice"><a href="#startedservice" aria-hidden="true" class="header-anchor">#</a> <code>StartedService</code></h3> <p>— <code>Context.startService()</code> 方式启动</p> <p>会调用到的生命周期方法</p> <p><code>onCreate()</code> —&gt; <code>onStartCommand(Intent, int, int)</code> —&gt;</p> <p><code>Context.stopService()</code> or <code>stopSelf()</code> —&gt; <code>onStop</code></p> <h3 id="boundservice"><a href="#boundservice" aria-hidden="true" class="header-anchor">#</a> <code>BoundService</code></h3> <p>— <code>Context.bindService()</code> 方式启动连接到服务</p> <p><code>onCreate()</code> —&gt; <code>但不会运行onStartCommand</code> —&gt; <code>onBind</code> -&gt; <code>onServiceConnected</code> --&gt; <code>onUnbind</code></p> <p>使用 <code>bindService</code> 启动服务后调用者和服务绑定到了一起，当调用者被销毁，服务也立即结终止。</p> <p>一旦 unBind 后, <code>service</code> 还是处于运行状态, 这时再去 <code>bind</code> 就不会调用 <code>onBind</code>, 而是直接调用 <code>onServiceConnected</code>,</p> <p>既然 <code>bind</code> 失败那么 <code>unbind</code> 自然也不会调用了</p> <p>也就是说 <code>bind</code>, <code>unbind</code> 启动服务后(调用 <code>startService</code> 后)只能绑定一次, 只要 <code>unbind</code> 后 再次 <code>bind</code> 就不会调用 <code>onBind</code> 方法</p> <p>如果某个组件通过调用<code>startService()</code>启动了 Service（系统会回调<code>onStartCommand()</code>方法），那么直到在 Service 中手动调用<code>stopSelf()</code>方法、或在其他组件中手动调用<code>stopService()</code>方法，该 Service 才会停止。</p> <hr> <p>如果某个组件通过调用<code>bindService()</code>绑定了 Service（系统不会回调<code>onStartCommand()</code>方法），只要该组件与 Service 处于绑定状态，Service 就会一直运行，当 Service 不再与组件绑定时，该 Service 将被 destroy。</p> <h2 id="startedservice-使用场景"><a href="#startedservice-使用场景" aria-hidden="true" class="header-anchor">#</a> StartedService 使用场景</h2> <p>主要也就是生命周期方法 <code>onStartCommand</code> 的使用场景</p> <p>在上面的生命周期方法中更重要的是理解两种不同启动方式下调用不同的生命周期方法</p> <p>毕竟两种不同的服务启动方式, 也对应着两种不同功能的服务类型</p> <p><strong>StartedService</strong> 类型, 指的是通过调用 <code>Context.startService()</code> 来启动服务, 一般用来完成某个耗时的功能, 比如 , 下载某个文件,</p> <p>而且这种耗时的操作一般是写在 <code>onStartCommand</code> 这个方法中新建线程来完成</p> <p>而且它还控制着服务的退出和重新启动, 因此它是 <code>StartedService</code> 中最重要的生命周期方法</p> <p>当然完成这种耗时操作的功能, 还可以通过 <code>IntentService</code> , 它是官方提供的一个使用范例</p> <p>如果每次只需要执行一个耗时的操作的话, 用 <code>IntentService</code> 就挺方便</p> <p>如果有多个耗时操作那么就需要在 <code>onStartCommand</code> 方法中自己通过新建线程来实现</p> <p>当在 <code>activiey</code> 或其他组件中调用 <code>startService</code> 方法的时候会触发 <code>Service</code> 的 <code>onStartCommand</code> 方法</p> <p><code>onStartCommand()</code>：当其他组件调用 <code>startService()</code>方法请求启动 <code>Service</code> 时，该方法被回调。一旦 <code>Service</code> 启动，它会在后台独立运行。</p> <p>当 <code>Service</code> 执行完以后，需调用 <code>stopSelf()</code> 或 <code>stopService()</code>方法停止 <code>Service。（若您只希望</code> <code>bind Service</code>，则无需调用这些方法）</p> <p>总的来说 , 一般情况下, 如果只需要一个耗时的操作的话, 可以使用 IntentService 因为那就是官方提供的对 <code>StartedService</code> 的使用</p> <p>如果有多个耗时的操作的话, 那就需要直接使用 <code>onStartCommand</code> 在里面新建多个线程</p> <h3 id="onstartcommand-返回值"><a href="#onstartcommand-返回值" aria-hidden="true" class="header-anchor">#</a> onStartCommand 返回值</h3> <p><code>onStartCommand()</code>返回一个 flags 整形变量，该变量必须是下列常量之一</p> <ul><li><p><a href="https://developer.android.com/reference/android/app/Service.html#START_NOT_STICKY" target="_blank" rel="noopener noreferrer"><code>START_NOT_STICKY</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：该返回值表示服务不需要自动重新启动.</p> <p>执行完<code>onStartCommand()</code>方法后，服务就会被 kill 了 , 在没有再次启动服务前, 该服务就是非启动状态</p> <p>该模式适合完成获取某个特定结果的操作, 而且该操作能被终止.</p> <p>当内存紧张的时候可以在迟些时候主动再次调用服务.</p> <p>这种类型的服务举例如:</p> <p>从服务器获取数据, 需要设置定时器, 每 n 分钟启动一次服务,</p> <p>每次启动服务就会调用一次<code>onStartCommand</code> , 在该方法中新建线程去访问网络</p> <p>如果线程终止被 kill 掉, 服务不会自己重新启动, 不会重新调用 onStartCommand.</p> <p>只有当定时器到时间才会主动再次该启动服务</p></li></ul> <hr> <ul><li><p><a href="https://developer.android.com/reference/android/app/Service.html#START_STICKY" target="_blank" rel="noopener noreferrer"><code>START_STICKY</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p> <p>若在服务启动后, <code>onStartCommand()</code>执行中的新建的线程如果被终止 kill，</p> <p>那么服务会依然保留在启动状态,但原本传递过来的 intent 将被丢失, 稍后系统会重新创建服务,</p> <p>因为原本服务还在启动状态, 于是新建的服务实例会再次调用 onStartCommand</p> <p>注意新建服务是需要 intent 对象的, 原本的 intent 在新建服务时是不会被保留的,</p> <p>除非有 pending intents 传递，否则将使用<code>null intent</code>来创建服务</p> <p>该模式适合在特定时间某个任务是一定启动状态或者停止状态, 比如在后台播放音乐。</p></li></ul> <hr> <ul><li><p><a href="https://developer.android.com/reference/android/app/Service.html#START_REDELIVER_INTENT" target="_blank" rel="noopener noreferrer"><code>START_REDELIVER_INTENT</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p> <p>该返回值表示, 当服务启动后 onStartCommand 中新建的线程被 kill 后,</p> <p>原本的 intent 数据将一直保留, 并且稍后将重新启动服务,直到服务调用 stopSelf 停止服务为止</p> <p>在原本使用参数 intent 启动后 onStartCommand 中的服务进程没有完成, 没有正常退出的话,</p> <p>那么则重新启动服务, 所以重启服务时传递的 intent 不是 null, 依然用原来的 intent 重新运行 onStartCommand</p></li></ul> <h3 id="startforeground-前台服务"><a href="#startforeground-前台服务" aria-hidden="true" class="header-anchor">#</a> startForeground 前台服务</h3> <p>startForeground 方法让服务在前台运行, 默认情况下服务是在后台运行的,</p> <p>这种前台运行模式可以用来显示需要在状态栏持续显示的 notification 通知,</p> <p>后台运行的服务进程当系统需要的时候可能会被 kill 掉回收内存, 且一般不会有什么不好的影响</p> <p>而如果你把服务设置成前台运行, 它不会被系统自动回收, 同时如果当前台服务被终止就会打断影响到用户,</p> <p>比如, 如果将后台运行的音乐设置成前台服务运行, 当该服务被终止, 音乐会停止播放</p> <p>一些特殊要求必须使用前台服务, 比如, 一些 app 服务在后台更新数据的同时, 还需要在状态栏一直显示一些信息</p> <p>书 第一行代码中有介绍</p> <h2 id="intentservice"><a href="#intentservice" aria-hidden="true" class="header-anchor">#</a> IntentService</h2> <h2 id="binder"><a href="#binder" aria-hidden="true" class="header-anchor">#</a> Binder</h2> <p>进程间通信有管道, socket, 共享内存等方法, 其中有种方法就是 Binder</p> <p>安卓中的 Binder 也是进程间通讯的一种方式</p> <p>比如:</p> <p>进程 1 要调用进程 2 中的某个方法 , 系统有进程安全限制的,不能直接访问其他进程资源</p> <p>那么实现方式就是用服务器端和客户端 cs 结构并且结合 binder 来实现进程通信,</p> <p>流程:</p> <p>serivce 端定义 binder 接口, 提供的服务暴露出去</p> <p>client 发送请求</p> <p>service 端内部方法, 通过建立映射, 让这个映射可以访问到 service 的内部方法,</p> <p>client 和 service 通过 binder 建立连接后, 都能访问到该映射,于是实现了 client 访问 server 内部方法</p> <p>调用端就是 client 端,</p> <p>被调用端就是 service 端,</p> <p>如果他们是在一个进程内, 那么就是本地服务</p> <p>如果不是一个进程内就是远程服务, 远程调用</p> <p>创建 BoundService</p> <p>必须提供 IBinder , client 将可以通过这个接口来和 service 端交互</p> <p>可以通过三种方法来提供 IBinder 接口</p> <ol><li>扩展 Binder 类 , 在自定义 Service 类中定义内部类继承 Binder 类</li> <li>使用 Messenger</li> <li>使用 AIDL</li></ol> <h3 id="本地服务"><a href="#本地服务" aria-hidden="true" class="header-anchor">#</a> 本地服务</h3> <p>使用 Binder 接口来实现本地服务 Demo</p> <p>服务端, 在自定义 Service 类中定义内部类继承 Binder 类,</p> <p>且在这个继承自 Binder 的内部类中, 我们可以定义提供给 client 使用的方法.</p> <p>客户端, 比如在 Activity 中使用</p> <p><code>bindService(bindIntent, conn, Context.BIND_AUTO_CREATE);</code></p> <p>来启动服务和建立连接, 其中 conn 是 <code>ServiceConnection</code> 对象</p> <p>ServiceConnection 客户端用来访问 Binder 中提供的方法</p> <h2 id="startedservice-和-boundservice-区别"><a href="#startedservice-和-boundservice-区别" aria-hidden="true" class="header-anchor">#</a> startedService 和 BoundService 区别</h2> <ol><li><strong>应用退出的情况下两种服务的运行状态不同</strong></li></ol> <p>但这里说的应用退出都是指的按 Back 键退回到桌面</p> <p>进程的 5 种状态参考 <a href="https://www.cnblogs.com/andy-songwei/p/9845771.html" target="_blank" rel="noopener noreferrer">安卓进程五个等级<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><code>startedService</code> 和 启动它的 <code>Activity</code> 不会同生共死, 当 <code>activity</code> 退出了 , <code>service</code> 依然在运行</p> <p><code>BoundService</code> 和启动它的 <code>Acaptivity</code> 同生共死 , <code>bound</code> 在一起了当 <code>activity</code> 退出了 , <code>service</code> 也就 <code>unbind</code> 而且 <code>distroy</code> 了</p> <p>按 back 键, App 进程如果没有 <code>startedService</code> 开启，会从一个前台进程转变为一个空进程；</p> <p>对于有 <code>startedService</code> 运行的情况，和按 <code>Home</code> 键一样 进入后台进程</p> <p>如果某个 <code>Activity</code> 正确实现了生命周期方法，并保存了其当前状态，
则进程进入后台和切换到前台, 其进程不会对用户体验产生明显影响，因为当用户导航回该 <code>Activity</code> 时会恢复其所有可见状态。</p> <p>如果是 <code>BoundService</code> 按 <code>back</code> 键退回到桌面那么进程进入到空进程状态, 并且 <code>BoundService</code> 会 <code>unbind</code> 后 <code>distroy</code></p> <p>如果进程被关闭了呢? 按多任务键后退出进程, 那么当进程关闭回收内存了, 服务也会随着<code>app</code> 退出, 那么 <code>startedService</code> 是会退出的</p> <p>如果是按 home 键, 应用进程是 hidden 状态, 那么对服务有没有影响?</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.f8bee57c.js" defer></script><script src="/assets/js/6.6621a9ba.js" defer></script>
  </body>
</html>
