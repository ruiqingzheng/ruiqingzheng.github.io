(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{182:function(t,a,e){"use strict";e.r(a);var s=e(0),r=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"http-请求中的-form-data-与-request-payload-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-请求中的-form-data-与-request-payload-的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" HTTP 请求中的 Form Data 与 Request Payload 的区别")]),t._v(" "),e("p",[t._v("参考")]),t._v(" "),e("p",[t._v("https://www.cnblogs.com/Abner5/p/7559851.html")]),t._v(" "),e("p",[t._v("https://my.oschina.net/zimingforever/blog/737414")]),t._v(" "),e("p",[t._v("前端开发中经常会用到 AJAX 发送异步请求，对于 POST 类型的请求会附带请求数据。而常用的两种传参方式为：Form Data 和 Request Payload。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://images2017.cnblogs.com/blog/1018462/201709/1018462-20170920093039978-2100563214.png",alt:"img"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"https://images2017.cnblogs.com/blog/1018462/201709/1018462-20170920093047056-655827777.png",alt:"img"}})]),t._v(" "),e("h1",{attrs:{id:"get-请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#get-请求","aria-hidden":"true"}},[t._v("#")]),t._v(" GET 请求")]),t._v(" "),e("p",[t._v("使用 get 请求时，参数会以 key=value 的形式拼接在请求的 url 后面。例如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("`http://m.baidu.com/address/getlist.html?limit=50&offset=0&t=1502345139870`\n")])])]),e("p",[t._v("但是受限于请求 URL 的长度限制，一般参数较少时会使用 get 请求。")]),t._v(" "),e("h1",{attrs:{id:"post-请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#post-请求","aria-hidden":"true"}},[t._v("#")]),t._v(" POST 请求")]),t._v(" "),e("p",[t._v("当参数数量较多，且对数据有一定安全性要求时，会考虑用 post 请求传递参数数据。POST 请求的参数数据是在请求体中。")]),t._v(" "),e("h2",{attrs:{id:"方式一：-form-data-形式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方式一：-form-data-形式","aria-hidden":"true"}},[t._v("#")]),t._v(" 方式一： Form Data 形式")]),t._v(" "),e("p",[t._v("当 POST 请求的请求头里设置 Content-Type: application/x-www-form-urlencoded(默认), 参数在请求体以标准的 Form Data 的形式提交，以&符号拼接，参数格式为 key=value&key=value&key=value...")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://images2017.cnblogs.com/blog/1018462/201709/1018462-20170920093132150-1553778311.png",alt:"img"}})]),t._v(" "),e("p",[t._v("前端代码设置：")]),t._v(" "),e("p",[t._v("xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); xhr.send('a=1&b=2&c=3');")]),t._v(" "),e("p",[t._v("在 servlet 中，后端可以通过 request.getParameter(name)的形式来获取表单参数。")]),t._v(" "),e("h2",{attrs:{id:"方式二：request-payload-形式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方式二：request-payload-形式","aria-hidden":"true"}},[t._v("#")]),t._v(" 方式二：Request Payload 形式")]),t._v(" "),e("p",[t._v('如果使用 AJAX 原生 POST 请求,请求头里设置 Content-Type:application/json，请求的参数会显示在 Request Payload 中，参数格式为 JSON 格式：{"key":"value","key":"value"...}，这种方式可读性会更好。')]),t._v(" "),e("p",[e("img",{attrs:{src:"https://images2017.cnblogs.com/blog/1018462/201709/1018462-20170920093208759-1131445967.png",alt:"img"}})]),t._v(" "),e("p",[t._v("后端可以使用 getRequestPayload 方法来获取。")]),t._v(" "),e("h1",{attrs:{id:"form-data-和-request-payload-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#form-data-和-request-payload-区别","aria-hidden":"true"}},[t._v("#")]),t._v(" Form Data 和 Request Payload 区别")]),t._v(" "),e("ol",[e("li",[t._v("如果请求头里设置 Content-Type: application/x-www-form-urlencoded，那么这个请求被认为是表单请求，参数出现在 Form Data 里，格式为 key=value&key=value&key=value...")]),t._v(" "),e("li",[t._v("原生的 AJAX 请求头里设置 Content-Type:application/json，或者使用默认的请求头 Content-Type:text/plain;参数会显示在 Request payload 块里提交。")])]),t._v(" "),e("p",[t._v("formdata 和 requestpayload 到底有什么区别呢、为什么用 fecth 的时候，提交的数据都变成了 request payload？")]),t._v(" "),e("p",[t._v("对于 get 请求，表单参数以 name=value&name1=value1 的形式附到 url 的后面")]),t._v(" "),e("p",[t._v("对于 post 请求，表单参数是在请求体中，也是以 name=value&name1=value1 的形式在请求体中，并且 post 请求的 Content-Type 为 application/x-www-form-urlencoded，参数是在请求体中，即请求中的 Form Data。在 servlet 中，可以通过 request.getParameter(name)的形式来获取表单参数。")]),t._v(" "),e("p",[t._v("但是如果是原生的 ajax 请求，请求的 Content-Type 为 text/plain;charset=UTF-8，而请求表单参数在 RequestPayload 中。此时的 POST 请求是不会读取请求体数据和进行相应的参数处理的，即不会解析表单数据来放到 request parameter map 中。所以通过 request.getParameter(name)是获取不到的。此时 servelet 中只能用解析流的解析")]),t._v(" "),e("p",[t._v("为什么原生的 ajax 后者 fetch 不能获取 form data 呢？")]),t._v(" "),e("p",[t._v("jquery 在执行 post 请求时，会设置 Content-Type 为 application/x-www-form-urlencoded，所以服务器能够正确解析，而使用原生 ajax 请求时，如果不显示的设置 Content-Type，那么默认是 text/plain，这时服务器就不知道怎么解析数据了，所以才只能通过获取原始数据流的方式来进行解析请求数据。")]),t._v(" "),e("p",[t._v("解决方案是什么呢？可以再请求的时候增加")]),t._v(" "),e("p",[t._v("\\you have not provided enough information how you use the send function, but I assume that you do not set mime type to specify you are sending form data")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("xhr"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("setRequestHeader")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Content-type'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'application/x-www-form-urlencoded'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("the data sent are in this case encoded as you encode a query string")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("xhr"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("send")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'name=foo&value=bar'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])])}],!1,null,null,null);a.default=r.exports}}]);