(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{207:function(e,t,s){"use strict";s.r(t);var r=s(0),a=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("div",{staticClass:"content"},[s("p",[s("strong",[e._v("## 跨域问题")])]),e._v(" "),s("p",[e._v("model 也就是 api 访问服务器端的时候 , 服务器往往和前端的部署不在一个地址, 比如端口不一样, 或者是 ip 不一样")]),e._v(" "),s("p",[e._v("此时, 前端在获取数据的时候, 如果去访问不同端口地址的 api 服务器, 那么浏览器的安全策略会提示")]),e._v(" "),s("p",[e._v("类似下面的 8084 是前端的测试服务器, 3333 端口是 api 服务器")]),e._v(" "),s("p",[e._v("```js")]),e._v(" "),s("p",[e._v("Access to XMLHttpRequest at 'http://localhost:3333/user/login' from origin 'http://localhost:8084' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource.")]),e._v(" "),s("p",[e._v("```")]),e._v(" "),s("p",[e._v("在这个时候, 只能让前端去访问相同 ip 端口的 api 地址, 比如"),s("code",[e._v("http://localhost:8084/user/login")])]),e._v(" "),s("p",[e._v("然后在这个服务器上设置转发 (和反向代理是一样的), 8084 端口服务器当遇到 /user/login 地址请求的时候, 就把这个请求转发给 3333 端口服务器")]),e._v(" "),s("p",[e._v("当数据返回的时候, 因为 8084 转发了请求, 于是 3333 端口服务器数据先返回给 8084 , 由 8084 发送给前端浏览器, 于是端口一致也就不存在跨域了")]),e._v(" "),s("p",[e._v("对于跨域而言, 最好的解决方式就是转发, 即使在部署的时候, 用的也是 nginx 配置的反向代理, 开发阶段用的是 express 的 proxy ,")]),e._v(" "),s("h2",{attrs:{id:"http-server-的代理功能来实现跨域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-server-的代理功能来实现跨域","aria-hidden":"true"}},[e._v("#")]),e._v(" http server 的代理功能来实现跨域")]),e._v(" "),s("p",[e._v("无论是nginx的代理 还是在express 中使用代理功能")]),e._v(" "),s("p",[e._v("本质上都是一样的, 都是用的 http server 的 proxy 功能")]),e._v(" "),s("p",[e._v("比如")]),e._v(" "),s("p",[e._v(".vue配置文件设置代理")]),e._v(" "),s("p",[e._v("在用vue-cli3构建的前端项目中有vue.config.js文件，在其中添加如下代码")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("devServer: {   proxy: {        '/apis': {    //将www.example.com映射为/apis\n            target: 'https://www.example.com',  // 接口域名\n            secure: false,  // 如果是https接口，需要配置这个参数\n            changeOrigin: true,  //是否跨域\n            pathRewrite: {\n                '^/apis': ''   //需要rewrite的,\n            }              \n        }\n  }}\n")])])]),s("p",[e._v("nginx 的配置参考 前端项目部署.md 这个笔记,  有提到如何进行转发请求")]),e._v(" "),s("p",[e._v("而且, nginx 配置中还涉及到客户端真实ip的获取")]),e._v(" "),s("h3",{attrs:{id:"服务器端修改http响应头"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务器端修改http响应头","aria-hidden":"true"}},[e._v("#")]),e._v(" 服务器端修改http响应头")]),e._v(" "),s("p",[e._v("由服务器决定是否允许跨域，如果允许，服务器会在响应头中设置字段来告诉浏览此次请求合法，则浏览器不会将请求包丢弃，从而完成跨域。再次举个nodejs服务器的栗子：")]),e._v(" "),s("p",[e._v("但这个经过测试经常不起作用")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//设置跨域访问\napp.all('*',function (req, res, next) {\n    res.header('Access-Control-Allow-Origin', '*');\n    res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild');\n    res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS');\n    if (req.method == 'OPTIONS') {\n        res.send(200); /让options请求快速返回/\n    }\n    else {\n        next();\n    }\n});\n")])])]),s("h2",{attrs:{id:"临时设置浏览器允许跨域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#临时设置浏览器允许跨域","aria-hidden":"true"}},[e._v("#")]),e._v(" 临时设置浏览器允许跨域")]),e._v(" "),s("p",[e._v("这个当然不是生产环境下的方案 , 如果只需要临时测试一下, 那么可以设置浏览器允许跨域")]),e._v(" "),s("p",[e._v("一般还是没有这样去做,    一般还是采用其他方案, 设置浏览器只是验证下的确是浏览器做了这个安全限制")]),e._v(" "),s("p",[e._v("1.浏览器设置跨域")]),e._v(" "),s("p",[e._v("在PC端开发，chrome浏览器是我们前端必不可少的开发工具，用chrome解决跨域简单粗暴。")]),e._v(" "),s("p",[e._v("1)右键chrome选择属性")]),e._v(" "),s("p",[e._v("2）选择快捷方式")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/11/1683afda30697945?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),e._v(" "),s("p",[e._v("3)在目标后面空格 加上 --disable-web-security --user-data-dir=C:(--user-data-dir是自定义目录)")]),e._v(" "),s("p",[e._v("打开浏览器，轻松解决跨域问题")]),e._v(" "),s("h2",{attrs:{id:"jsonp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jsonp","aria-hidden":"true"}},[e._v("#")]),e._v(" jsonp")]),e._v(" "),s("p",[e._v("这个方案也是比较好的方案,   但也有隐患,  具体看jsonp 的笔记")]),e._v(" "),s("h2",{attrs:{id:"混合开发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#混合开发","aria-hidden":"true"}},[e._v("#")]),e._v(" 混合开发")]),e._v(" "),s("p",[e._v("这个就属于比较牛的解决方案了")]),e._v(" "),s("p",[e._v("原生请求是不存在跨域问题的, 比如在安卓端, 安卓原生okhttp 库可以去请求任何api 地址来获取数据")]),e._v(" "),s("p",[e._v("然后原生代码和前端代码就需要进行交互了,  也就是说前端的数据请求因为浏览器限制才存在跨域问题")]),e._v(" "),s("p",[e._v("现在把前端的数据请求放到原生去请求, 得到数据后通过jsbridge等交互方式进行传递数据,")]),e._v(" "),s("p",[e._v("这样也就解决了跨域问题, 只是这个比较有难度")]),e._v(" "),s("h2",{attrs:{id:"参考资源"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考资源","aria-hidden":"true"}},[e._v("#")]),e._v(" 参考资源")]),e._v(" "),s("p",[e._v("https://segmentfault.com/a/1190000009399953\nhttps://segmentfault.com/a/1190000011007043")])])}],!1,null,null,null);t.default=a.exports}}]);